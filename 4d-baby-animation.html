<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸˆ Baby's 4D Wonder World ğŸˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #87CEEB 0%, #FFB6C1 50%, #FFD700 100%);
            cursor: pointer;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .tap-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            animation: bounce 2s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        .tap-message.hide {
            opacity: 0;
            transition: opacity 1s;
        }

        .celebration {
            position: absolute;
            font-size: 5rem;
            pointer-events: none;
            z-index: 200;
            animation: celebrate 2s ease-out forwards;
        }

        @keyframes celebrate {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: scale(0.5) translateY(-200px) rotate(360deg);
                opacity: 0;
            }
        }

        .emoji-trail {
            position: absolute;
            font-size: 3rem;
            pointer-events: none;
            z-index: 150;
            animation: trail 1.5s ease-out forwards;
        }

        @keyframes trail {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <div class="tap-message" id="tapMessage">ğŸ‘† Tap Anywhere! ğŸ‘†</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js variables
        let scene, camera, renderer;
        let animals = [];
        let balloons = [];
        let stars = [];
        let currentBgHue = 0;

        // Cute animals and objects
        const emojiList = ['ğŸ¶', 'ğŸ±', 'ğŸ»', 'ğŸ°', 'ğŸ¦Š', 'ğŸ¼', 'ğŸ¯', 'ğŸ¦', 'ğŸ¸', 'ğŸ·', 
                           'ğŸˆ', 'â­', 'ğŸŒŸ', 'ğŸ¨', 'ğŸµ', 'ğŸŒˆ', 'ğŸ¦‹', 'ğŸŒº', 'ğŸª', 'ğŸ¡'];
        
        const colors = [
            0xFF6B9D, 0xFFA06B, 0xFFEB3B, 0x4CAF50, 
            0x2196F3, 0x9C27B0, 0xFF5722, 0x00BCD4
        ];

        let soundEnabled = true;
        let tapCount = 0;

        // Initialize Three.js
        function initThreeJS() {
            const canvas = document.getElementById('gameCanvas');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 20);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xffd700, 1, 50);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff69b4, 1, 50);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            // Create initial floating objects
            createFloatingStars();

            window.addEventListener('resize', onWindowResize);
            
            // Click/tap handler
            canvas.addEventListener('click', handleTap);
            canvas.addEventListener('touchstart', handleTap);
        }

        // Create floating stars
        function createFloatingStars() {
            for (let i = 0; i < 20; i++) {
                createStar();
            }
        }

        function createStar() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)],
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.5
            });
            const star = new THREE.Mesh(geometry, material);
            
            star.position.set(
                (Math.random() - 0.5) * 40,
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 40 - 20
            );
            
            star.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                ),
                rotationSpeed: (Math.random() - 0.5) * 0.05
            };
            
            scene.add(star);
            stars.push(star);
        }

        // Create cute 3D animal/emoji
        function createCuteObject(x, y) {
            const emoji = emojiList[Math.floor(Math.random() * emojiList.length)];
            
            // Create sprite with emoji
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            // Draw glow background
            const gradient = context.createRadialGradient(128, 128, 30, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.5)`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 256, 256);
            
            // Draw emoji
            context.font = 'bold 180px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(emoji, 128, 128);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            
            // Convert screen coords to 3D
            const vector = new THREE.Vector3(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            sprite.position.copy(pos);
            sprite.position.z = 15; // Start close
            sprite.scale.set(8, 8, 1);
            
            sprite.userData = {
                emoji: emoji,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    -0.4 // Zoom away
                ),
                rotationSpeed: (Math.random() - 0.5) * 0.1,
                life: 1,
                pulseTime: 0
            };
            
            scene.add(sprite);
            animals.push(sprite);
            
            // Play sound
            playSound(emoji);
            
            // Create celebration emoji at tap point
            createCelebration(x, y, emoji);
            
            return sprite;
        }

        // Create celebration effect
        function createCelebration(x, y, emoji) {
            const celebration = document.createElement('div');
            celebration.className = 'celebration';
            celebration.textContent = emoji;
            celebration.style.left = x + 'px';
            celebration.style.top = y + 'px';
            document.body.appendChild(celebration);
            
            setTimeout(() => celebration.remove(), 2000);
            
            // Create trails
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const trail = document.createElement('div');
                    trail.className = 'emoji-trail';
                    trail.textContent = ['âœ¨', 'â­', 'ğŸ’«', 'ğŸŒŸ'][Math.floor(Math.random() * 4)];
                    trail.style.left = (x + (Math.random() - 0.5) * 100) + 'px';
                    trail.style.top = (y + (Math.random() - 0.5) * 100) + 'px';
                    document.body.appendChild(trail);
                    
                    setTimeout(() => trail.remove(), 1500);
                }, i * 100);
            }
        }

        // Handle tap/click
        function handleTap(e) {
            e.preventDefault();
            
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            
            createCuteObject(x, y);
            
            // Hide tap message after first tap
            if (tapCount === 0) {
                document.getElementById('tapMessage').classList.add('hide');
            }
            tapCount++;
            
            // Change background color
            currentBgHue = (currentBgHue + 0.05) % 1;
            document.body.style.background = 
                `linear-gradient(135deg, 
                    hsl(${currentBgHue * 360}, 70%, 70%) 0%, 
                    hsl(${(currentBgHue + 0.2) * 360}, 70%, 70%) 50%, 
                    hsl(${(currentBgHue + 0.4) * 360}, 70%, 70%) 100%)`;
        }

        // Play sound based on emoji
        function playSound(emoji) {
            if (!soundEnabled) return;
            
            // Create AudioContext
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Different sounds for different emojis
            let frequency = 440;
            
            if ('ğŸ¶ğŸ±ğŸ»ğŸ°'.includes(emoji)) {
                frequency = 523.25; // C5
            } else if ('ğŸ¦ŠğŸ¼ğŸ¯ğŸ¦'.includes(emoji)) {
                frequency = 659.25; // E5
            } else if ('ğŸ¸ğŸ·'.includes(emoji)) {
                frequency = 392; // G4
            } else if ('ğŸˆâ­ğŸŒŸ'.includes(emoji)) {
                frequency = 783.99; // G5
            } else {
                frequency = 587.33; // D5
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
            
            // Add a second tone for harmony
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            
            osc2.connect(gain2);
            gain2.connect(audioContext.destination);
            
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(frequency * 1.5, audioContext.currentTime);
            
            gain2.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            osc2.start(audioContext.currentTime + 0.05);
            osc2.stop(audioContext.currentTime + 0.4);
        }

        // Play background music
        function playBackgroundMusic() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const notes = [523.25, 587.33, 659.25, 698.46, 783.99, 880, 987.77]; // C major scale
            let noteIndex = 0;
            
            function playNote() {
                if (!soundEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(notes[noteIndex], audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.8);
                
                noteIndex = (noteIndex + 1) % notes.length;
            }
            
            // Play a note every 1.5 seconds
            setInterval(playNote, 1500);
            playNote();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Animate animals/objects
            for (let i = animals.length - 1; i >= 0; i--) {
                const obj = animals[i];
                
                // Move with velocity
                obj.position.add(obj.userData.velocity);
                
                // Zoom away effect
                obj.userData.life -= 0.003;
                obj.material.opacity = obj.userData.life;
                
                // Pulse animation
                obj.userData.pulseTime += 0.05;
                const pulse = 1 + Math.sin(obj.userData.pulseTime) * 0.2;
                obj.scale.set(8 * pulse, 8 * pulse, 1);
                
                // Rotation
                obj.rotation.z += obj.userData.rotationSpeed;
                
                // Remove if too far or faded
                if (obj.userData.life <= 0 || obj.position.z < -50) {
                    scene.remove(obj);
                    animals.splice(i, 1);
                }
            }
            
            // Animate stars
            stars.forEach(star => {
                star.position.add(star.userData.velocity);
                star.rotation.x += star.userData.rotationSpeed;
                star.rotation.y += star.userData.rotationSpeed;
                
                // Bounce off boundaries
                if (Math.abs(star.position.x) > 20) star.userData.velocity.x *= -1;
                if (Math.abs(star.position.y) > 15) star.userData.velocity.y *= -1;
                if (Math.abs(star.position.z) > 20) star.userData.velocity.z *= -1;
            });
            
            // Gentle camera movement
            camera.position.x = Math.sin(Date.now() * 0.0005) * 2;
            camera.position.y = Math.cos(Date.now() * 0.0003) * 1.5;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }

        // Window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Auto-spawn random objects
        function autoSpawnObjects() {
            setInterval(() => {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                createCuteObject(x, y);
            }, 2000);
        }

        // Create random floating animations
        function createRandomAnimation() {
            setInterval(() => {
                // Create a burst of small sparkles
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
                        const material = new THREE.MeshPhongMaterial({ 
                            color: colors[Math.floor(Math.random() * colors.length)],
                            emissive: colors[Math.floor(Math.random() * colors.length)],
                            emissiveIntensity: 0.8
                        });
                        const sparkle = new THREE.Mesh(geometry, material);
                        
                        sparkle.position.set(
                            (Math.random() - 0.5) * 30,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        );
                        
                        sparkle.userData = {
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * 0.2,
                                (Math.random() - 0.5) * 0.2,
                                -0.3
                            ),
                            life: 1
                        };
                        
                        scene.add(sparkle);
                        
                        // Remove after animation
                        setTimeout(() => {
                            const fadeOut = () => {
                                sparkle.userData.life -= 0.05;
                                sparkle.material.opacity = sparkle.userData.life;
                                sparkle.position.add(sparkle.userData.velocity);
                                sparkle.scale.multiplyScalar(0.95);
                                
                                if (sparkle.userData.life > 0) {
                                    requestAnimationFrame(fadeOut);
                                } else {
                                    scene.remove(sparkle);
                                }
                            };
                            fadeOut();
                        }, 100);
                    }, i * 200);
                }
            }, 5000);
        }

        // Create rainbow effect
        function createRainbow() {
            const rainbowGroup = new THREE.Group();
            
            for (let i = 0; i < 7; i++) {
                const geometry = new THREE.TorusGeometry(5 + i * 0.5, 0.2, 16, 100);
                const hue = i / 7;
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 1, 0.5)
                });
                const arc = new THREE.Mesh(geometry, material);
                arc.rotation.x = Math.PI / 2;
                rainbowGroup.add(arc);
            }
            
            rainbowGroup.position.set(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 10,
                -20
            );
            
            scene.add(rainbowGroup);
            
            // Animate rainbow
            let frame = 0;
            const animateRainbow = () => {
                frame++;
                rainbowGroup.rotation.y += 0.02;
                rainbowGroup.position.z -= 0.2;
                
                if (frame < 150) {
                    requestAnimationFrame(animateRainbow);
                } else {
                    scene.remove(rainbowGroup);
                }
            };
            animateRainbow();
        }

        // Periodically create rainbows
        function autoRainbows() {
            setInterval(createRainbow, 8000);
        }

        // Play cheerful sounds periodically
        function playCheerfulSound() {
            if (!soundEnabled) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const notes = [523.25, 659.25, 783.99, 1046.5]; // C E G C chord
            
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                }, index * 100);
            });
        }

        // Play happy sounds periodically
        function autoHappySounds() {
            setInterval(() => {
                playCheerfulSound();
            }, 10000);
        }

        // Create balloons that float up
        function createBalloon() {
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)],
                shininess: 100
            });
            const balloon = new THREE.Mesh(geometry, material);
            
            balloon.position.set(
                (Math.random() - 0.5) * 30,
                -20,
                (Math.random() - 0.5) * 20 - 10
            );
            
            balloon.userData = {
                floatSpeed: 0.05 + Math.random() * 0.05,
                swaySpeed: Math.random() * 0.02,
                swayAmount: Math.random() * 3
            };
            
            scene.add(balloon);
            balloons.push(balloon);
        }

        // Auto-create balloons
        function autoBalloons() {
            setInterval(createBalloon, 3000);
            
            // Animate existing balloons
            setInterval(() => {
                for (let i = balloons.length - 1; i >= 0; i--) {
                    const balloon = balloons[i];
                    balloon.position.y += balloon.userData.floatSpeed;
                    balloon.position.x = Math.sin(Date.now() * 0.001 * balloon.userData.swaySpeed) * balloon.userData.swayAmount;
                    
                    if (balloon.position.y > 25) {
                        scene.remove(balloon);
                        balloons.splice(i, 1);
                    }
                }
            }, 16);
        }

        // Initialize
        initThreeJS();
        animate();
        autoSpawnObjects();
        createRandomAnimation();
        autoRainbows();
        autoHappySounds();
        autoBalloons();
        
        // Start background music after first interaction
        document.body.addEventListener('click', () => {
            if (tapCount === 1) {
                playBackgroundMusic();
            }
        }, { once: false });
    </script>
</body>
</html>


